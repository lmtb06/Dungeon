@startuml

abstract class GameObject {
    GameObject(eventManager : EventManager, animationManager : AnimationManager)
}
GameObject *-- EventManager
GameObject *-- AnimationManager

interface AI {
}

abstract class GameCharacter {
    - health : int
    - speedMeterPerSecond : float
    - body : Body
    - contactDamages : int
    - meleeDamages : int
    + move(vecteur : Vector2) : void
    + getPosition() : Vector2
    + attack(target : GameCharacter) : void
    + takeDamage(amount : int) : void
}
GameCharacter --|> GameObject


class Player {
    applyPowerUp(powerUp : PowerUp) : void
}
Player --|> GameCharacter
Player "1" -- "0..1" Weapon : has >
Player "1" -- "0..*" PowerUp : has >


class Monster {
    patrol()
}
Monster --|> GameCharacter
Monster *-- AI : -ai

class Weapon {
    attack()
}

class PowerUp {
    activate()
    deactivate()
}
PowerUp --|> GameObject

class Trap {

}

class Teleporter {

}
Teleporter --|> GameObject

class Level {
    - world : World
    - viewport : Viewport
    - player : Player
    - loadRoom(room : Room)
    - unloadRoom(room : Room)
    - loadPlayerCharacter() : void
    - createBoundary(x : float, y : float, width: float, height :float)
    + getCamera() : OrthographicCamera
    + getPlayer() : Player
    + update(delta : float) : void
    + getWorld() : World
    + getViewport() : Viewport
    + getPlayer() : Player
    + dispose() : void
}

Level "1"--"1..*" Room : has >
Level "1"--"1" Player : contains >

class Room {
    spawnMonster()
}

Room -- "0..*" PowerUp : may have >
Room -- "0..*" Weapon : may have >
Room -- "1..*" Door : has >
Room -- "0..*" Trap : may have >
Room -- "0..*" Monster : may have >

class Door {

}


class DungeonGame {
    create() : void
    setInputProcessor(inputProcessor : InputProcessor) : void
    dispose() : void
}
DungeonGame --|> Game
DungeonGame "1"--"1" ScreenManager
DungeonGame *-- AnimationManager : -animationManager
DungeonGame *-- EventManager : -eventManager
DungeonGame *-- InputProcessor : -currentInputProcessor

class ScreenManager {
    changeScreen(screen : GameScreen) : void
    getCurrentScreen()
}
ScreenManager -- GameScreen : -currentScreen >
ScreenManager -- GameOverScreen : has >
ScreenManager -- WorldScreen : has >
ScreenManager -- MainMenuScreen : has >
ScreenManager -- PauseScreen : has >
ScreenManager -- EndGameScreen : has >

abstract GameScreen {
    + getInputProcessor() : InputProcessor
    + setInputProcessor() : void
}
GameScreen --|> Screen
GameScreen *-- InputProcessor
MainMenuScreen --|> GameScreen
WorldScreen --|> GameScreen
PauseScreen --|> GameScreen
GameOverScreen --|> GameScreen
EndGameScreen --|> GameScreen

class MainMenuScreen {

}


class WorldScreen {
    - moveLeft : boolean
    - moveRight : boolean
    - moveUp : boolean
    - moveDown : boolean
    + setMoveLeft(state : boolean) : void
    + setMoveRight(state : boolean) : void
    + setMoveUp(state : boolean) : void
    + setMoveDown(state : boolean) : void
}
WorldScreen *-- Level : -currentLevel

class PauseScreen {

}

class GameOverScreen {

}

class EndGameScreen {

}

class AnimationManager {
    + addAnimation(animation: Animation): void
    + removeAnimation(animation: Animation): void
    + playAnimation(animation: Animation): void
    + pauseAnimation(animation: Animation): void
    + stopAnimation(animation: Animation): void
    + update(deltaTime: float): void
}

class GameObjectAnimation {
    
}
GameObjectAnimation "0..1"--"1" GameObject

class EventManager {
    + subscribe(eventType: String, listener: EventListener): void
    + unsubscribe(eventType: String, listener: EventListener): void
    + triggerEvent(event: Event): void
    + queueEvent(event: Event): void
    + processEvents(): void
}

interface EventListener {
    onEvent(event: Event): void
}

class Event {
    - type: String
    - data: Object
    + getType(): String
    + getData(): Object
}

class WorldScreenInputProcessor {
    WorldScreenInputProcessor(worldScreen : WorldScreen)
}
WorldScreenInputProcessor ..|> InputProcessor
WorldScreenInputProcessor *-- WorldScreen
interface InputProcessor
@enduml